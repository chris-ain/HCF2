var curtains;let pl;function curtainsmain(e){$(document).ready(function(){function n(e,n,t){return(1-t)*e+t*n*.5}const t=[],r=document.getElementsByClassName("plane");let o=0;var a=0;(curtains=new Curtains({container:document.getElementById("canvas"),watchScroll:!0,pixelRatio:Math.min(50,window.devicePixelRatio),premultipliedAlpha:!0})).onRender(()=>{void 0}).onScroll(()=>{const e=curtains.getScrollDeltas();e.y=-e.y,e.y>60?e.y=60:e.y<-60&&(e.y=-60),Math.abs(e.y)>Math.abs(a)&&(a=n(a,e.y,.5)),Math.abs(e.y)>Math.abs(o)&&(o=n(o,e.y,.5))}).onError(()=>{document.body.classList.add("no-curtains","planes-loaded")}).onContextLost(()=>{curtains.restoreContext()}),curtains.disableDrawing(),e.on("scroll",e=>{!function(e,n){curtains.updateScrollValues(e,n)}(e.scroll.x,e.scroll.y),curtains.needRender()});document.getElementById("debug-value");r.length;const i={vertexShader:"\n  precision mediump float;\n  \n  // default mandatory variables\n  attribute vec3 aVertexPosition;\n  attribute vec2 aTextureCoord;\n\n  uniform mat4 uMVMatrix;\n  uniform mat4 uPMatrix;\n\n  uniform mat4 planeTextureMatrix;\n\n  // custom variables\n  varying vec3 vVertexPosition;\n  varying vec2 vTextureCoord;\n\n  uniform float uPlaneDeformation;\n\n  void main() {\n      vec3 vertexPosition = aVertexPosition;\n\n      // cool effect on scroll\n      vertexPosition.y += sin(((vertexPosition.y * vertexPosition.x + 5.0) / 2.0) * 3.141592) * (sin(uPlaneDeformation / 100.0))/1.3;\n\n      gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);\n\n      // varyings\n      vVertexPosition = vertexPosition;\n      vTextureCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n  }\n",fragmentShader:"\n  precision mediump float;\n  \n  varying vec3 vVertexPosition;\n  varying vec2 vTextureCoord;\n\n  uniform sampler2D planeTexture;\n\n  void main() {\n      // just display our texture\n      gl_FragColor = texture2D(planeTexture, vTextureCoord);\n  }\n",shareProgram:!0,widthSegments:10,heightSegments:10,drawCheckMargins:{top:100,right:0,bottom:100,left:0},uniforms:{planeDeformation:{name:"uPlaneDeformation",type:"1f",value:0}}};for(let e=0;e<r.length;e++){const n=new Plane(curtains,r[e],i);t.push(n),u(e)}function u(e){const n=t[e];pl=t[e],n&&n.onLoading(function(){}).onReady(function(){n.setRenderTarget(l),e===t.length-1&&document.body.classList.add("planes-loaded")}).onRender(function(){n.uniforms.planeDeformation.value=a,n.textures[0].setScale(new Vec2(1+Math.abs(o)/500))})}var l=new RenderTarget(curtains),s=new ShaderPass(curtains,{fragmentShader:"\n    precision mediump float;\n\n    varying vec3 vVertexPosition;\n    varying vec2 vTextureCoord;\n  \n    uniform sampler2D uRenderTexture;\n  \n    uniform float uScrollEffect;\n  \n    void main() {\n        vec2 textureCoords = vTextureCoord;\n  \n        vec2 redTextCoords = vec2(vTextureCoord.x, vTextureCoord.y - uScrollEffect / 400.0);\n        vec2 greenTextCoords = vec2(vTextureCoord.x, vTextureCoord.y - uScrollEffect / 3000.0);\n        vec2 blueTextCoords = vec2(vTextureCoord.x, vTextureCoord.y - uScrollEffect / 3000.0);\n  \n        vec4 red = texture2D(uRenderTexture, redTextCoords);\n        vec4 green = texture2D(uRenderTexture, greenTextCoords);\n        vec4 blue = texture2D(uRenderTexture, blueTextCoords);\n  \n        vec4 finalColor = vec4(red.r, green.g, blue.b, min(1.0, red.a * blue.a * green.a));\n        gl_FragColor = finalColor;\n    }\n",renderTarget:l,depthTest:!1,uniforms:{scrollEffect:{name:"uScrollEffect",type:"1f",value:0}}});s&&s.onRender(function(){s.uniforms.scrollEffect.value=o})})}function destroyPlane(){for(let e=0;e<pl.length;e++)pl[e].remove();pl=[]}export{curtains,pl,curtainsmain,destroyPlane};
